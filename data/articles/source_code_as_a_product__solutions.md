
Source Code as Product

3 parts

introduction
solutions
experiment



## introduction

mostly self explanatory

source code is the interface that the developers use everyday
explains trends toward serverless (programming all time in console)
   as well as notebook popularity



explain meaning of title
source code is the product because it's the product that you use to build and change the other product
need to change the product? the work involved is a function of the interface of the source code product
interface design becomes really important
how easy is it to make changes to an app? 
so no, when treat src code as prod, it works is not done because it's obviously not the only requirement.
a "product" is obviously non-static. it should do  things. but we treat code as static 

giving due attention. reduce pressure from other places in org to design bad software


### arguments (for why phrase should be used)

1. mental. leads to low code quality because developers treat code as done when it works
   developers that know better can have a hard time defending this.
   source code as product can be a good explanatin
   need holistic view of software not just code in Git

2. reality. source is the tool used to build all software, so the easier it is to use, the more efficient will be the software dev process
2a. onboarding
2b. planning / estimation
2c. bugs from complexity. incidental benefits when forcing software to not just be the stuff that makes other stuff work. 


3. 


*corollary*. dev becomes customer.



## solutions

can't design product to anticipate all changes of course, unless that product is a turing-complete programming language
ended up solving a straightforward problem and ended up writing a prog lang? I know you're reading this. 
have to find balance of course. and that is the real art of programming. knowing which code to write and what interface it should have. 


### code review

code review, comments, documentation, etc...

the social solutions. because rely on person to integrate them and do them. not automatic
hard to do consistently, doesn't scale

linting, CI, 
right direction. automated, take social solutions out of equation, for example with linting, remove inefficiency caused by debate over little things about code structure


### functional programming

solve social problems with technical problems. strong typing is great interface. 
see article about haskell programming. type-driven development.
future because you have power of ordinary prog lang, but ability to express any constraints 


## experiment

end with experiment
create basic UI for two different versions of source code
example program?? 
find out that interface for modifying product, looks like product itself if done right
this is because our code approaches being a specification for the product

argument for functional progamming. because to solve these problems you want those tools

show TS vs Elm implementation

